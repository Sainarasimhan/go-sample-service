// +build wireinject
// The build tag makes sure the stub is not built in the final build.

/* Sample Golang Micro-Servcie
  built with go-kit and has 3 below components,
  transport - Supports REST and gRPC and does request validation.
  endpoints - Wraps Service Layer and provides non business logging,instrumentation along with
			  rate limiting,circuit breaker functionality.
  service   - Implements Actual business logic. Support synchronous and asynchronous requests and
			  does business specific instrumentation and logging.

  Repository - Postgres Database is used as backend and all DB logic is abstracted in repo package.
  Non-Functional logic are implemented as middelwares e.g. logging, error handling in each major component.

  uses logging, error handling and config package from other git repos, along with few third party packages.
*/

// TODO
// Add Testing for individual packages
// More Documentation
// Improve Error Handling for dependencies

//go:generate wire gen -output_file_prefix main- main.go
//go:generate protoc --go_out=plugins=grpc:. -I ../ pb/sample.proto

package main

import (
	"log"

	"github.com/Sainarasimhan/sample/pkg/sample"
	"github.com/google/wire"
	"github.com/oklog/oklog/pkg/group"

	//Debug info
	_ "net/http/pprof"
	//Export Debug vars
	_ "expvar"
)

// Injector to automatically build dependencies.
// New File will be autogenerated
func InitSample() (fl sample.FunctionsList, cleanup func(), err error) {
	// Initialize PROD Set from Sample, Refer Sample packages for available sets
	wire.Build(sample.ProdSet)
	return fl, cleanup, err
}

func main() {
	// Handle Profiling Requests
	sample.HandleProfilers()

	// Initialize Sample Service
	fl, cleanup, err := InitSample()
	if err != nil {
		log.Fatal(err)
	}

	// Now we're to the part of the func main where we want to start actually
	// running things, like servers bound to listeners to receive connections.
	//
	// The method is the same for each component: add a new actor to the group
	// struct, which is a combination of 2 anonymous functions: the first
	// function actually runs the component, and the second function should
	// interrupt the first function and cause it to return. It's in these
	// functions that we actually bind the Go kit server/handler structs to the
	// concrete transports and run them.

	// Initiate Funtionalities of Sample service
	// Invokes HTTP, gRPC, PubSub, Debug Transport Handlers if enabled
	var g group.Group
	{
		for _, fn := range fl {
			fn := fn
			g.Add(func() error {
				return fn.Start()
			}, func(error) {
				fn.Shutdown()
			})
		}
	}

	// Run functions
	log.Println("exit", g.Run())
	cleanup() // Clean and exit
}
