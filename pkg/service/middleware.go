package service

import (
	"context"
	"fmt"

	"cloud.google.com/go/errorreporting"
	log "github.com/Sainarasimhan/Logger"
	svcerr "github.com/Sainarasimhan/go-error/err"
	"go.opentelemetry.io/otel/api/metric"
)

type errorMiddleware struct {
	next Service
	*log.Logger
	*errorreporting.Client
}

type instrumentingMiddleware struct {
	next               Service
	createCnt, listCnt metric.BoundInt64Counter
}

type middleware func(Service) Service

// ErrorMiddleware - Middleware to return uniform error types based of rpc codes.
// Does Error reporting, if enabled
func ErrorMiddleware(lg *log.Logger, e *errorreporting.Client) middleware {
	return func(next Service) Service {
		return &errorMiddleware{next: next, Logger: lg, Client: e}
	}
}

//InstrumentingMiddleware - Captures the number of requests received
func InstrumentingMiddleware(cr, ls metric.BoundInt64Counter) middleware {
	return func(next Service) Service {
		return &instrumentingMiddleware{next: next, createCnt: cr, listCnt: ls}
	}
}

func (e *errorMiddleware) Create(ctx context.Context, cr CreateRequest) (err error) {
	defer e.handleError(&err, true)
	return e.next.Create(ctx, cr)

}

func (e *errorMiddleware) CreateAsync(ctx context.Context, cr CreateRequest) (err error) {
	defer e.handleError(&err, true)
	return e.next.CreateAsync(ctx, cr)
}

func (e *errorMiddleware) List(ctx context.Context, lr ListRequest) (D Details, err error) {
	defer e.handleError(&err, true)
	return e.next.List(ctx, lr)

}

// handleError - does 3 functionalities
// Handles panic generated by service layer and sends internal error
// Does GCP error reporting, if enalbed
// Coverts any non-standard error to internal error
func (e *errorMiddleware) handleError(err *error, report bool) {
	// Handle Panics created by service layer
	if msg := recover(); msg != nil {
		e.Error("Panic", "handler")("panic received %v", msg)
		*err = svcerr.InternalErr(fmt.Sprintf("Panic handling request, error - %s", msg))
		report = true // report error in case of panic
	}

	if *err != nil {
		// Do Error Reporting
		if e.Client != nil && report {
			e.Client.Report(errorreporting.Entry{
				Error: *err,
			})
		}
		// Covert to type Internal Error, if error is not a valid type
		if !svcerr.IsValid(*err) {
			*err = svcerr.InternalErr((*err).Error())
		}
	}
}

// NewErrorReportingClient Create Error reporting Client, pass GCP project ID
func NewErrorReportingClient(projectID string, lg *log.Logger) *errorreporting.Client {
	if projectID == "" {
		return nil // Don't create client for zero values
	}
	ctx := context.Background()

	errorClient, err := errorreporting.NewClient(ctx, projectID, errorreporting.Config{
		ServiceName: "Sample-Service",
		OnError: func(err error) {
			lg.Error("ErrorReport", "Failure")("Could not log error: %v", err)
		},
	})
	if err != nil {
		lg.Println(err)
	}
	return errorClient
}

func (i *instrumentingMiddleware) Create(ctx context.Context, cr CreateRequest) (err error) {
	err = i.next.Create(ctx, cr)
	i.createCnt.Add(ctx, 1)
	return
}

func (i *instrumentingMiddleware) CreateAsync(ctx context.Context, cr CreateRequest) (err error) {
	err = i.next.CreateAsync(ctx, cr)
	i.createCnt.Add(ctx, 1)
	return
}

func (i *instrumentingMiddleware) List(ctx context.Context, lr ListRequest) (D Details, err error) {
	D, err = i.next.List(ctx, lr)
	i.listCnt.Add(ctx, 1)
	return
}
